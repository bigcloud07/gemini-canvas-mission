<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì›¹ ê¸°ë°˜ 3D FPS ê²Œì„</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Teko:wght@400;600&display=swap');

    body {
        margin: 0;
        overflow: hidden;
        background-color: #000;
        font-family: 'Teko', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        user-select: none;
    }

    #blocker {
        position: absolute;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.6);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 10;
        backdrop-filter: blur(3px);
    }

    #instructions {
        color: #ffffff;
        text-align: center;
        cursor: pointer;
    }

    #instructions h1 {
        font-family: 'Black Ops One', system-ui;
        font-size: 80px;
        margin-bottom: 10px;
        color: #8BC34A; /* ì¢€ë¹„ ë¶„ìœ„ê¸°ì˜ ë…¹ìƒ‰ */
        text-shadow: 4px 4px 0px #111, 0 0 20px #FF0000;
        letter-spacing: 5px;
    }

    #instructions p {
        font-family: 'Teko', sans-serif;
        font-size: 26px;
        color: #cccccc;
        letter-spacing: 1px;
    }

    /* í¬ë¡œìŠ¤í—¤ì–´ (ì¡°ì¤€ì„ ) */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 5;
        }

        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background-color: rgba(255, 0, 0, 0.9); /* ëˆˆì— ì˜ ë„ëŠ” ë¹¨ê°„ìƒ‰ìœ¼ë¡œ ë³€ê²½ */
        }

        #crosshair::before {
            top: 9px; left: 0; width: 20px; height: 2px;
        }

        #crosshair::after {
            top: 0; left: 9px; width: 2px; height: 20px;
        }

        /* HUD (ì²´ë ¥, ì ìˆ˜) */
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(15, 20, 15, 0.85);
            padding: 15px 25px;
            border-left: 5px solid #8BC34A;
            border-radius: 4px 15px 15px 4px;
            color: white;
            font-family: 'Teko', sans-serif;
            font-size: 26px;
            z-index: 5;
            pointer-events: none;
            box-shadow: 0 4px 15px rgba(0,0,0,0.6);
        }

        .hud-item {
            margin-bottom: 12px;
            letter-spacing: 1px;
        }

        .hud-label-flex {
            display: flex;
            justify-content: space-between;
            width: 200px;
            margin-bottom: 2px;
            color: #ddd;
        }

        #health-bar-container {
            width: 200px;
            height: 14px;
            background-color: rgba(255, 0, 0, 0.2);
            border: 1px solid #555;
            border-radius: 2px;
            box-shadow: inset 0 0 5px #000;
        }

        #health-bar {
            width: 100%;
            height: 100%;
            background-color: #ff3333;
            transition: width 0.2s, background-color 0.2s;
            box-shadow: 0 0 8px #ff3333;
        }

        /* ê²½í—˜ì¹˜ ë°” ì¶”ê°€ */
        #exp-bar-container {
            width: 200px;
            height: 14px;
            background-color: rgba(0, 150, 255, 0.2);
            border: 1px solid #555;
            border-radius: 2px;
            box-shadow: inset 0 0 5px #000;
            margin-top: 2px;
        }

        #exp-bar {
            width: 0%;
            height: 100%;
            background-color: #0088ff;
            transition: width 0.3s;
            box-shadow: 0 0 8px #0088ff;
        }

        /* í”¼ê²© íš¨ê³¼ */
        #damage-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(255, 0, 0, 0.4);
            z-index: 4;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.1s;
        }

        /* ì´ì•Œ HUD */
        #ammo-hud {
            position: absolute;
            bottom: 30px;
            right: 30px;
            left: auto; /* ê¸°ì¡´ ì™¼ìª½ ì •ë ¬ ë¬´íš¨í™” */
            background: rgba(15, 20, 15, 0.85);
            padding: 10px 30px;
            border-right: 5px solid #FF9800;
            border-radius: 15px 4px 4px 15px;
            color: white;
            font-family: 'Teko', sans-serif;
            font-size: 44px;
            z-index: 5;
            pointer-events: none;
            box-shadow: 0 4px 15px rgba(0,0,0,0.6);
            text-align: right;
        }

        .gun-name {
            font-size: 28px;
            color: #ffffff;
            letter-spacing: 3px;
            text-align: right;
            margin-bottom: 5px; /* AMMO ê¸€ìê°€ ì‚¬ë¼ì§„ ê³µê°„ì„ ìì—°ìŠ¤ëŸ½ê²Œ ë„ì›Œì¤Œ */
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 2px;
            text-shadow: 0 0 5px rgba(255,255,255,0.5);
        }

        /* ë³´ìŠ¤ í´ë¦¬ì–´ ë©”ì‹œì§€ */
        #boss-msg {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #FFD700;
            font-family: 'Black Ops One', cursive;
            font-size: 70px;
            text-shadow: 0 0 20px #FF0000, 4px 4px 0px #000;
            display: none;
            z-index: 20;
            pointer-events: none;
            letter-spacing: 3px;
        }

        /* í›ˆì¥ ì»¨í…Œì´ë„ˆ */
        #medals {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 40px;
            z-index: 5;
            pointer-events: none;
            text-shadow: 2px 2px 2px #000;
        }
    </style>
    <!-- Three.js ì½”ì–´ ë° PointerLockControls ë¡œë“œ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
</head>
<body>

    <!-- UI ìš”ì†Œë“¤ -->
    <div id="hud">
        <div class="hud-item" id="score-text">SCORE : 0</div>
        <div class="hud-item" id="level-text">LEVEL : 1</div>
        <div class="hud-item">
            <div class="hud-label-flex"><span>HP</span> <span id="health-text">100</span></div>
            <div id="health-bar-container"><div id="health-bar"></div></div>
        </div>
        <div class="hud-item">
            <div class="hud-label-flex"><span>EXP</span> <span id="exp-text">0 / 100</span></div>
            <div id="exp-bar-container"><div id="exp-bar"></div></div>
        </div>
    </div>
    
    <div id="crosshair"></div>
    <div id="damage-overlay"></div>
    <div id="ammo-hud">
        <div class="gun-name">M4A1</div>
        <span id="ammo-text">30 / 30</span>
    </div>
    <div id="boss-msg">BOSS CLEARED!</div>
    <div id="medals"></div>

    <div id="blocker">
        <div id="instructions">
            <h1 id="title-text">ZOMBIE HUNTER</h1>
            <p id="desc-text">í´ë¦­í•˜ì—¬ ê²Œì„ ì‹œì‘</p>
            <p style="font-size: 20px; margin-top: 20px; color: #aaa;">
                ì¡°ì‘ë²•: W, A, S, D (ì´ë™) | ìŠ¤í˜ì´ìŠ¤ë°” (ì í”„) | R (ì¥ì „)<br>
                ë§ˆìš°ìŠ¤ (ì‹œì ) | ì¢Œí´ë¦­ (ì‚¬ê²© / 5Lv ì—°ì‚¬) | ìš°í´ë¦­ (15Lv ìœ íƒ„)
            </p>
        </div>
    </div>

    <script>
        // ì „ì—­ ë³€ìˆ˜ ì„¤ì •
        let camera, scene, renderer, controls;
        let objects = []; // ì¥ì• ë¬¼ (ì¶©ëŒ ì²˜ë¦¬ìš©)
        let enemies = []; // ì  ë°°ì—´
        let particles = []; // íƒ€ê²© ì´í™íŠ¸ íŒŒí‹°í´ ë°°ì—´
        let clouds = []; // êµ¬ë¦„ ë°°ì—´
        let grenades = []; // ìœ íƒ„ ë°°ì—´
        let raycaster;
        let gun;

        // ê²Œì„ ìƒíƒœ ë³€ìˆ˜
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let canJump = false;
        
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();

        let score = 0;
        let health = 100;
        let isGameOver = false;

        // ê²½í—˜ì¹˜ ë° ë ˆë²¨ ë³€ìˆ˜
        let level = 1;
        let currentExp = 0;
        let maxExp = 100; // ì´ˆê¸° í•„ìš” ê²½í—˜ì¹˜

        // íƒ„ì•½ ê´€ë ¨ ë³€ìˆ˜
        let maxAmmo = 30;
        let currentAmmo = maxAmmo;
        let isReloading = false;
        let isFiring = false; // ì—°ì‚¬ ìƒíƒœ
        let lastFireTime = 0; // ë§ˆì§€ë§‰ ë°œì‚¬ ì‹œê°„
        let lastGrenadeTime = 0; // ë§ˆì§€ë§‰ ìœ íƒ„ ë°œì‚¬ ì‹œê°„

        // ê²Œì„ ì‹œê°„ ë° ë³´ìŠ¤ ê´€ë ¨ ë³€ìˆ˜
        let activeTime = 0;
        let nextBossTime = 30; // 30ì´ˆë§ˆë‹¤ ë³´ìŠ¤ ë“±ì¥

        // ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸
        let audioCtx;
        let reloadSoundBuffer = null; // ì²¨ë¶€ëœ ì˜¤ë””ì˜¤ ë²„í¼ ë³€ìˆ˜

        // DOM ìš”ì†Œ ë¡œë“œ í›„ ê²Œì„ ì´ˆê¸°í™”
        window.onload = function() {
            init();
            animate();
        };

        function init() {
            // 1. ì”¬ ë° ì¹´ë©”ë¼ ì„¤ì •
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x5ca0d3); // ë” ê¹Šê³  ì‚¬ì‹¤ì ì¸ í‘¸ë¥¸ í•˜ëŠ˜
            scene.fog = new THREE.FogExp2(0xcce0ff, 0.012); // ê±°ë¦¬ê°ì„ ì£¼ëŠ” ì‚¬ì‹¤ì ì¸ ì•ˆê°œ íš¨ê³¼ (ëŒ€ê¸° ì›ê·¼ê°)

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 2; // í”Œë ˆì´ì–´ ëˆˆë†’ì´

            // 2. ì¡°ëª… ì„¤ì • (HemisphereLight ì¶”ê°€ë¡œ ì‚¬ì‹¤ì„± ê·¹ëŒ€í™”)
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6); // í•˜ëŠ˜ë¹›ê³¼ ë•…ì˜ ë°˜ì‚¬ê´‘ ë¶„ë¦¬
            hemiLight.position.set(0, 200, 0);
            scene.add(hemiLight);

            const dirLight = new THREE.DirectionalLight(0xffffee, 1.0); // ë”°ëœ»í•œ í–‡ë¹›
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            
            // ê·¸ë¦¼ì í•´ìƒë„ ë° ë²”ìœ„ ë„“íˆê¸°
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.top = 60;
            dirLight.shadow.camera.bottom = -60;
            dirLight.shadow.camera.left = -60;
            dirLight.shadow.camera.right = 60;
            scene.add(dirLight);

            // 3. ì»¨íŠ¸ë¡¤ëŸ¬ (PointerLock) ì„¤ì •
            controls = new THREE.PointerLockControls(camera, document.body);

            const blocker = document.getElementById('blocker');
            const instructions = document.getElementById('instructions');

            instructions.addEventListener('click', function () {
                // ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸ ì´ˆê¸°í™” (ë¸Œë¼ìš°ì € ì •ì±…ìƒ ì‚¬ìš©ì ì¸í„°ë™ì…˜ ì‹œ í™œì„±í™” í•„ìš”)
                if (!audioCtx) {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    loadAudioFiles(); // ì¥ì „ ì†Œë¦¬ íŒŒì¼ ë¡œë“œ
                }
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }

                if (isGameOver) {
                    resetGame();
                }
                controls.lock(); // ë§ˆìš°ìŠ¤ ì»¤ì„œ ìˆ¨ê¸°ê³  í™”ë©´ ê³ ì •
            });

            controls.addEventListener('lock', function () {
                blocker.style.display = 'none';
            });

            controls.addEventListener('unlock', function () {
                blocker.style.display = 'flex';
                if (!isGameOver) {
                    document.getElementById('title-text').innerText = "ì¼ì‹œì •ì§€";
                    document.getElementById('desc-text').innerText = "í´ë¦­í•˜ì—¬ ê³„ì†í•˜ê¸°";
                }
            });

            scene.add(controls.getObject());

            // 4. í‚¤ë³´ë“œ ì…ë ¥ ì´ë²¤íŠ¸ ì„¤ì •
            const onKeyDown = function (event) {
                switch (event.code) {
                    case 'ArrowUp':
                    case 'KeyW': moveForward = true; break;
                    case 'ArrowLeft':
                    case 'KeyA': moveLeft = true; break;
                    case 'ArrowDown':
                    case 'KeyS': moveBackward = true; break;
                    case 'ArrowRight':
                    case 'KeyD': moveRight = true; break;
                    case 'Space':
                        if (canJump === true) velocity.y += 90; // ì í”„ ì†ë„ë¥¼ ë‚®ì¶° ë¶€ë“œëŸ½ê²Œ ì‹œì‘ (ê¸°ì¡´ 200 -> 90)
                        canJump = false;
                        break;
                    case 'KeyR':
                        if (!isReloading && currentAmmo < maxAmmo && !isGameOver) { // MAX_AMMOë¥¼ maxAmmoë¡œ ìˆ˜ì •
                            reloadGun();
                        }
                        break;
                }
            };

            const onKeyUp = function (event) {
                switch (event.code) {
                    case 'ArrowUp':
                    case 'KeyW': moveForward = false; break;
                    case 'ArrowLeft':
                    case 'KeyA': moveLeft = false; break;
                    case 'ArrowDown':
                    case 'KeyS': moveBackward = false; break;
                    case 'ArrowRight':
                    case 'KeyD': moveRight = false; break;
                }
            };

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            // 5. ì‚¬ê²©(ë§ˆìš°ìŠ¤ í´ë¦­) ì´ë²¤íŠ¸ ì„¤ì •
            raycaster = new THREE.Raycaster();
            
            // ë§ˆìš°ìŠ¤ í´ë¦­ ë° ë–¼ê¸° ì´ë²¤íŠ¸ (ìš°í´ë¦­ ë©”ë‰´ ë°©ì§€ í¬í•¨)
            document.addEventListener('mousedown', (e) => {
                if (!controls.isLocked || isGameOver || isReloading) return;
                if (e.button === 0) { // ì¢Œí´ë¦­ (ì‚¬ê²©)
                    isFiring = true;
                    // ë‹¨ë°œ ë° ì—°ì‚¬ ì‹œì‘ì 
                    if (performance.now() - lastFireTime > 150) {
                        fireGun();
                    }
                } else if (e.button === 2) { // ìš°í´ë¦­ (ìœ íƒ„ ë°œì‚¬ - 15ë ˆë²¨)
                    if (level >= 15) {
                        fireGrenade();
                    }
                }
            });
            document.addEventListener('mouseup', (e) => {
                if (e.button === 0) isFiring = false;
            });
            document.addEventListener('contextmenu', e => e.preventDefault()); // ìš°í´ë¦­ ë©”ë‰´ ë°©ì§€

            // 6. í™˜ê²½ ìš”ì†Œ(ë°”ë‹¥, ë¬´ê¸° ë“±) ìƒì„±
            createEnvironment();
            createClouds(); // êµ¬ë¦„ ìƒì„±
            createGun();

            // 7. ë Œë”ëŸ¬ ì„¤ì •
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // 8. ì´ˆê¸° ì  ìƒì„±
            for (let i = 0; i < 15; i++) {
                spawnEnemy();
            }

            // ì°½ í¬ê¸° ì¡°ì ˆ ì´ë²¤íŠ¸
            window.addEventListener('resize', onWindowResize);
        }

        function createEnvironment() {
            // ë°”ë‹¥ (ê·¸ë¦¬ë“œ í…ìŠ¤ì²˜ íš¨ê³¼ë¥¼ ìœ„í•œ í‰ë©´)
            const floorGeometry = new THREE.PlaneGeometry(200, 200, 100, 100);
            floorGeometry.rotateX(-Math.PI / 2);
            
            // ì •ì  ìƒ‰ìƒìœ¼ë¡œ ë°”ë‹¥ ìŠ¤íƒ€ì¼ë§ (ì´ˆì› ëŠë‚Œì˜ ë‹¤ì–‘í•œ ë…¹ìƒ‰)
            const position = floorGeometry.attributes.position;
            const colors = [];
            for (let i = 0; i < position.count; i++) {
                // ë°ê³  ë‹¤ì–‘í•œ í†¤ì˜ ì”ë””ìƒ‰
                colors.push(
                    0.2 + Math.random() * 0.1, // R
                    0.6 + Math.random() * 0.2, // G
                    0.2 + Math.random() * 0.1  // B
                );
            }
            floorGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const floorMaterial = new THREE.MeshStandardMaterial({ 
                vertexColors: true,
                roughness: 0.9, // ë¹› ë°˜ì‚¬ë¥¼ ì¤„ì—¬ í™/ì”ë”” ëŠë‚Œ ê°•ì¡°
                metalness: 0.1
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.receiveShadow = true; // ì”ë”” ë°”ë‹¥ì— ê·¸ë¦¼ì í‘œì‹œ
            scene.add(floor);

            // ë‹¨ë‹¨í•œ ë³´ì´ì§€ ì•ŠëŠ” ë°”ë‹¥ (ë¬¼ë¦¬ìš©) - ì‹œê°ì ìœ¼ë¡œëŠ” ìˆ¨ê¹€
            const solidFloorGeo = new THREE.PlaneGeometry(200, 200);
            solidFloorGeo.rotateX(-Math.PI / 2);
            const solidFloorMat = new THREE.MeshBasicMaterial({ visible: false }); 
            const solidFloor = new THREE.Mesh(solidFloorGeo, solidFloorMat);
            scene.add(solidFloor);

            // ê¸°ë‘¥(ì¥ì• ë¬¼) ìƒì„± - ë‚˜ë¬´ ê¸°ë‘¥ ëŠë‚Œì˜ ê°ˆìƒ‰ìœ¼ë¡œ ë³€ê²½
            // ê³ ì • í¬ê¸° ëŒ€ì‹  ë„“ê³  ë‚®ì€ 'ì í”„ ê°€ëŠ¥í•œ ë°œíŒ' í˜•íƒœë¡œ ë¬´ì‘ìœ„ ìƒì„±
            const boxMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            
            for (let i = 0; i < 20; i++) {
                const w = 1.5 + Math.random() * 2.5; // ë„ˆë¹„ 1.5 ~ 4.0 (ë‘ê»˜ë¥¼ í¬ê²Œ ì¤„ì„)
                const h = 0.5 + Math.random() * 3; // ë†’ì´ 0.5 ~ 3.5 (ì í”„ ê°€ëŠ¥í•˜ê²Œ)
                const d = 1.5 + Math.random() * 2.5; // ê¹Šì´ 1.5 ~ 4.0 (ë‘ê»˜ë¥¼ í¬ê²Œ ì¤„ì„)
                const boxGeometry = new THREE.BoxGeometry(w, h, d);
                
                const box = new THREE.Mesh(boxGeometry, boxMaterial);
                box.position.x = Math.floor(Math.random() * 40 - 20) * 2;
                box.position.y = h / 2; // ë°”ë‹¥ë¶€í„° ì†Ÿì•„ë‚˜ì˜¤ê²Œ ì¤‘ì‹¬ì  ì„¤ì •
                box.position.z = Math.floor(Math.random() * 40 - 20) * 2;
                // í”Œë ˆì´ì–´ ì‹œì‘ ìœ„ì¹˜ ê·¼ì²˜ì—ëŠ” ê¸°ë‘¥ ì•ˆ ìƒê¸°ê²Œ
                if(Math.abs(box.position.x) < 5 && Math.abs(box.position.z) < 5) continue;
                
                box.castShadow = true;
                box.receiveShadow = true;
                scene.add(box);
                objects.push(box); // ì¶©ëŒ ë°°ì—´ì— ì¶”ê°€
            }
        }

        function createClouds() {
            // êµ¬ë¦„ í˜•íƒœ(ë¡œìš°í´ë¦¬)ì™€ ì¬ì§ˆ
            const cloudGeo = new THREE.DodecahedronGeometry(2, 0); 
            const cloudMat = new THREE.MeshLambertMaterial({ 
                color: 0xffffff, 
                flatShading: true,
                transparent: true,
                opacity: 0.95
            });

            for (let i = 0; i < 30; i++) { // 30ê°œì˜ êµ¬ë¦„ ë­‰ì¹˜ ìƒì„±
                const cloud = new THREE.Group();
                
                // êµ¬ë¦„ í•œ ê°œë‹¹ 3~6ê°œì˜ ë©ì–´ë¦¬ë¥¼ ë­‰ì³ì„œ ëª½ê¸€ëª½ê¸€í•˜ê²Œ ë§Œë“¦
                const partCount = 3 + Math.floor(Math.random() * 4);
                for (let j = 0; j < partCount; j++) {
                    const part = new THREE.Mesh(cloudGeo, cloudMat);
                    part.position.set(
                        (Math.random() - 0.5) * 4,
                        (Math.random() - 0.5) * 2,
                        (Math.random() - 0.5) * 4
                    );
                    const scale = 0.5 + Math.random() * 1.5;
                    part.scale.set(scale, scale, scale);
                    cloud.add(part);
                }

                // í•˜ëŠ˜ ë†’ì´ ë¬´ì‘ìœ„ ë°°ì¹˜
                cloud.position.set(
                    (Math.random() - 0.5) * 200,
                    25 + Math.random() * 15, // ë†’ì´ 25~40 ì‚¬ì´
                    (Math.random() - 0.5) * 200
                );
                
                // êµ¬ë¦„ì˜ ê°œë³„ ì´ë™ ì†ë„
                cloud.userData.speed = 0.5 + Math.random() * 1.5;

                scene.add(cloud);
                clouds.push(cloud);
            }
        }

        function createGun() {
            // ì¹´ë©”ë¼ì— ë¶™ì¼ ë¬´ê¸° ëª¨ë¸ ìƒì„± (AR-15 / M4 ëŒê²©ì†Œì´ ìŠ¤íƒ€ì¼)
            const gunGroup = new THREE.Group();
            
            // ì´ê¸° ë¶€ìœ„ë³„ ì¬ì§ˆ(ìƒ‰ìƒ) ì„¤ì •
            const gunMatDark = new THREE.MeshPhongMaterial({ color: 0x111111 }); // ì–´ë‘ìš´ ê²€ì€ìƒ‰
            const gunMatGrey = new THREE.MeshPhongMaterial({ color: 0x2b2b2b }); // ì§™ì€ íšŒìƒ‰ (í”Œë¼ìŠ¤í‹±/ê³ ë¬´ ë¶€ë¶„)
            const gunMatDetail = new THREE.MeshPhongMaterial({ color: 0x0a0a0a }); // ê°€ì¥ ì§„í•œ ê²€ì€ìƒ‰ (ë””í…Œì¼)

            // 1. ëª¸í†µ (Receiver)
            const receiverGeo = new THREE.BoxGeometry(0.06, 0.12, 0.3);
            const receiver = new THREE.Mesh(receiverGeo, gunMatDark);
            receiver.position.set(0, 0, 0);
            gunGroup.add(receiver);

            // 2. í•¸ë“œê°€ë“œ (ì´ì—´ ë®ê°œ)
            const handguardGeo = new THREE.BoxGeometry(0.07, 0.13, 0.35);
            const handguard = new THREE.Mesh(handguardGeo, gunMatGrey);
            handguard.position.set(0, 0, -0.32);
            gunGroup.add(handguard);

            // 3. ì´ì—´ (Barrel)
            const barrelGeo = new THREE.CylinderGeometry(0.012, 0.012, 0.4, 16);
            const barrel = new THREE.Mesh(barrelGeo, gunMatDark);
            barrel.rotation.x = Math.PI / 2;
            barrel.position.set(0, 0, -0.65);
            gunGroup.add(barrel);

            // 4. ì†Œì—¼ê¸° (Flash Hider)
            const flashGeo = new THREE.CylinderGeometry(0.018, 0.018, 0.06, 16);
            const flash = new THREE.Mesh(flashGeo, gunMatDetail);
            flash.rotation.x = Math.PI / 2;
            flash.position.set(0, 0, -0.88);
            gunGroup.add(flash);

            // 5. íƒ„ì°½ (Magazine)
            const magGeo = new THREE.BoxGeometry(0.045, 0.2, 0.08);
            const mag = new THREE.Mesh(magGeo, gunMatDark);
            mag.position.set(0, -0.15, -0.1);
            mag.rotation.x = -0.15; // ì‚´ì§ ì•ìœ¼ë¡œ ê¸°ìš¸ì„
            gunGroup.add(mag);

            // 6. ì†ì¡ì´ (Grip)
            const gripGeo = new THREE.BoxGeometry(0.035, 0.12, 0.06);
            const grip = new THREE.Mesh(gripGeo, gunMatDetail);
            grip.position.set(0, -0.12, 0.1);
            grip.rotation.x = 0.2; // ì‚´ì§ ë’¤ë¡œ ê¸°ìš¸ì„
            gunGroup.add(grip);

            // 7. ê°œë¨¸ë¦¬íŒ (Stock)
            const stockGeo = new THREE.BoxGeometry(0.05, 0.15, 0.2);
            const stock = new THREE.Mesh(stockGeo, gunMatDark);
            stock.position.set(0, -0.02, 0.28);
            gunGroup.add(stock);
            
            // ê°œë¨¸ë¦¬íŒ ì§€ì§€ëŒ€ (Stock Tube)
            const tubeGeo = new THREE.CylinderGeometry(0.015, 0.015, 0.15, 16);
            const tube = new THREE.Mesh(tubeGeo, gunMatGrey);
            tube.rotation.x = Math.PI / 2;
            tube.position.set(0, 0.02, 0.15);
            gunGroup.add(tube);

            // 8. ê°€ëŠ ì‡  (Front Sight)
            const frontSightGeo = new THREE.BoxGeometry(0.015, 0.08, 0.03);
            const frontSight = new THREE.Mesh(frontSightGeo, gunMatDark);
            frontSight.position.set(0, 0.08, -0.55);
            gunGroup.add(frontSight);

            // 9. ê°€ëŠ ì ë° ë ˆì¼ (Rear Sight / Rail)
            const rearSightGeo = new THREE.BoxGeometry(0.04, 0.04, 0.15);
            const rearSight = new THREE.Mesh(rearSightGeo, gunMatDark);
            rearSight.position.set(0, 0.08, -0.05);
            gunGroup.add(rearSight);
            
            // ì¡°ì¤€ì  (ë…¹ìƒ‰ ì•¼ê´‘ í¬ì¸íŠ¸)
            const aimGeo = new THREE.BoxGeometry(0.01, 0.01, 0.01);
            const aimMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const aim = new THREE.Mesh(aimGeo, aimMat);
            aim.position.set(0, 0.125, -0.55); // ê°€ëŠ ì‡  ìœ„ìª½ ëë¶€ë¶„
            gunGroup.add(aim);

            // í™”ë©´ ìš°ì¸¡ í•˜ë‹¨ì— ìœ„ì¹˜í•˜ë„ë¡ ì„¤ì •
            gunGroup.position.set(0.3, -0.2, -0.5);
            camera.add(gunGroup);
            scene.add(camera); // ì¹´ë©”ë¼ë¥¼ ì”¬ì— ì¶”ê°€í•´ì•¼ ìì‹ ìš”ì†Œë„ ë³´ì„
            
            gun = gunGroup;
        }

        function createZombie(isBoss = false) {
            const zombie = new THREE.Group();

            // ì¬ì§ˆ ì„¤ì • (ë³´ìŠ¤ ì—¬ë¶€ì— ë”°ë¼ ìƒ‰ìƒ ë‹¤ë¥´ê²Œ)
            const skinMat = new THREE.MeshPhongMaterial({ color: isBoss ? 0x9C27B0 : 0x8BC34A }); // ë³´ìŠ¤ëŠ” ë³´ë¼ìƒ‰ í”¼ë¶€
            const brainMat = new THREE.MeshPhongMaterial({ color: isBoss ? 0xFF0000 : 0xF48FB1 }); // ë³´ìŠ¤ëŠ” ë¶‰ì€ ë‡Œ
            const shirtMat = new THREE.MeshPhongMaterial({ color: isBoss ? 0x212121 : 0xB0BEC5 }); // ë³´ìŠ¤ëŠ” ê²€ì€ ì…”ì¸ 
            const pantsMat = new THREE.MeshPhongMaterial({ color: isBoss ? 0x4A148C : 0x455A64 }); // ë³´ìŠ¤ëŠ” ì§„ë³´ë¼ìƒ‰ ë°”ì§€
            const eyeMat = new THREE.MeshPhongMaterial({ color: isBoss ? 0xFFEB3B : 0xFFFFFF }); // ë³´ìŠ¤ëŠ” ë…¸ë€ ëˆˆììœ„
            const pupilMat = new THREE.MeshPhongMaterial({ color: isBoss ? 0xFF0000 : 0x222222 }); // ë³´ìŠ¤ëŠ” ë¹¨ê°„ ëˆˆë™ì

            // 1. ë¨¸ë¦¬ ê·¸ë£¹
            const headGroup = new THREE.Group();
            headGroup.position.set(0, 1.8, 0); // ëª¸í†µ ìœ„ì— ìœ„ì¹˜
            zombie.add(headGroup);

            const headGeo = new THREE.BoxGeometry(1.0, 1.0, 1.0); // í° ë¨¸ë¦¬
            const head = new THREE.Mesh(headGeo, skinMat);
            head.castShadow = true;
            headGroup.add(head);

            // ë‡Œ (ì™¼ìª½ ìœ„ ë…¸ì¶œ)
            const brainGeo = new THREE.BoxGeometry(0.5, 0.2, 0.5);
            const brain = new THREE.Mesh(brainGeo, brainMat);
            brain.position.set(-0.25, 0.55, 0);
            headGroup.add(brain);

            // ëˆˆ
            const eyeGeo = new THREE.BoxGeometry(0.3, 0.3, 0.1);
            const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
            leftEye.position.set(0.25, 0.1, 0.51);
            const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
            rightEye.position.set(-0.25, 0.1, 0.51);
            headGroup.add(leftEye, rightEye);

            const pupilGeo = new THREE.BoxGeometry(0.1, 0.1, 0.12);
            const leftPupil = new THREE.Mesh(pupilGeo, pupilMat);
            leftPupil.position.set(0.25, 0.1, 0.52);
            const rightPupil = new THREE.Mesh(pupilGeo, pupilMat);
            rightPupil.position.set(-0.25, 0.1, 0.52);
            headGroup.add(leftPupil, rightPupil);

            // ì…
            const mouthGeo = new THREE.BoxGeometry(0.3, 0.15, 0.1);
            const mouth = new THREE.Mesh(mouthGeo, pupilMat);
            mouth.position.set(0, -0.25, 0.51);
            headGroup.add(mouth);

            // 2. ëª¸í†µ
            const bodyGeo = new THREE.BoxGeometry(0.8, 0.8, 0.5);
            const body = new THREE.Mesh(bodyGeo, shirtMat);
            body.position.set(0, 0.9, 0); // ë‹¤ë¦¬ì™€ ë¨¸ë¦¬ ì‚¬ì´
            body.castShadow = true;
            zombie.add(body);

            // 3. íŒ” (ì–´ê¹¨ ì¤‘ì‹¬ íšŒì „ì„ ìœ„í•´ ê·¸ë£¹í•‘)
            const armGeo = new THREE.BoxGeometry(0.25, 0.7, 0.25);
            
            const leftArmGroup = new THREE.Group();
            leftArmGroup.position.set(0.55, 1.2, 0);
            const leftArm = new THREE.Mesh(armGeo, skinMat);
            leftArm.position.set(0, -0.35, 0);
            leftArm.castShadow = true;
            leftArmGroup.add(leftArm);
            zombie.add(leftArmGroup);

            const rightArmGroup = new THREE.Group();
            rightArmGroup.position.set(-0.55, 1.2, 0);
            const rightArm = new THREE.Mesh(armGeo, skinMat);
            rightArm.position.set(0, -0.35, 0);
            rightArm.castShadow = true;
            rightArmGroup.add(rightArm);
            zombie.add(rightArmGroup);

            // 4. ë‹¤ë¦¬ (ê³¨ë°˜ ì¤‘ì‹¬ íšŒì „ì„ ìœ„í•´ ê·¸ë£¹í•‘)
            const legGeo = new THREE.BoxGeometry(0.35, 0.5, 0.35);

            const leftLegGroup = new THREE.Group();
            leftLegGroup.position.set(0.22, 0.5, 0);
            const leftLeg = new THREE.Mesh(legGeo, pantsMat);
            leftLeg.position.set(0, -0.25, 0); // Y=0(ë°”ë‹¥)ì— ë”± ë§ê²Œ ì¡°ì ˆ
            leftLeg.castShadow = true;
            leftLegGroup.add(leftLeg);
            zombie.add(leftLegGroup);

            const rightLegGroup = new THREE.Group();
            rightLegGroup.position.set(-0.22, 0.5, 0);
            const rightLeg = new THREE.Mesh(legGeo, pantsMat);
            rightLeg.position.set(0, -0.25, 0);
            rightLeg.castShadow = true;
            rightLegGroup.add(rightLeg);
            zombie.add(rightLegGroup);

            // ì¶©ëŒ ì²˜ë¦¬ ë° ë ˆì´ìºìŠ¤íŒ…ì„ ìœ„í•œ ì†ì„± ì¶”ê°€
            zombie.traverse((child) => {
                if (child.isMesh) {
                    child.userData.parentZombie = zombie;
                }
            });

            // ì• ë‹ˆë©”ì´ì…˜ ì œì–´ìš© ë¶€ìœ„ ì €ì¥
            zombie.userData = {
                head: headGroup,
                leftArm: leftArmGroup,
                rightArm: rightArmGroup,
                leftLeg: leftLegGroup,
                rightLeg: rightLegGroup
            };

            return zombie;
        }

        function spawnEnemy() {
            // ì¼ë°˜ ì¢€ë¹„ ëª¨ë¸ ìƒì„±
            const enemy = createZombie(false);
            const sizeScale = 0.8 + Math.random() * 0.4; // 0.8 ~ 1.2 í¬ê¸° ë³€í˜•
            enemy.scale.set(sizeScale, sizeScale, sizeScale);

            // ë¬´ì‘ìœ„ ìœ„ì¹˜ì— ìŠ¤í° (í”Œë ˆì´ì–´ì™€ ë„ˆë¬´ ê°€ê¹ì§€ ì•Šê²Œ)
            let x, z;
            do {
                x = Math.random() * 80 - 40;
                z = Math.random() * 80 - 40;
            } while (Math.abs(x - camera.position.x) < 15 && Math.abs(z - camera.position.z) < 15);

            enemy.position.set(x, 0, z); // ë‹¤ë¦¬ ëì´ ë°”ë‹¥ì— ë‹¿ìœ¼ë¯€ë¡œ Y=0ìœ¼ë¡œ ìŠ¤í°
            
            // ì ì˜ ê°œì¸ ì†ì„± ë¶€ì—¬
            enemy.userData.speed = 1.5 + Math.random() * 2; // ì´ë™ ì†ë„
            enemy.userData.walkOffset = Math.random() * Math.PI * 2; // ê±·ê¸° ì• ë‹ˆë©”ì´ì…˜ ì˜¤í”„ì…‹
            enemy.userData.hp = 1; // ì¼ë°˜ ì¢€ë¹„ ì²´ë ¥
            enemy.userData.isBoss = false;
            enemy.userData.attackRadius = 2.5;

            scene.add(enemy);
            enemies.push(enemy);
        }

        function spawnBoss() {
            // ê±°ëŒ€ ë³´ìŠ¤ ì¢€ë¹„ ìƒì„±
            const boss = createZombie(true);
            const sizeScale = 3.5; // ê±°ëŒ€í•œ í¬ê¸°
            boss.scale.set(sizeScale, sizeScale, sizeScale);

            // ë³´ìŠ¤ëŠ” í”Œë ˆì´ì–´ì™€ ì¡°ê¸ˆ ë” ê±°ë¦¬ë¥¼ ë‘ê³  ìŠ¤í°
            let x, z;
            do {
                x = Math.random() * 80 - 40;
                z = Math.random() * 80 - 40;
            } while (Math.abs(x - camera.position.x) < 25 && Math.abs(z - camera.position.z) < 25);

            boss.position.set(x, 0, z);
            
            boss.userData.speed = 1.8; // ë³´ìŠ¤ëŠ” ì•½ê°„ ëŠë¦¬ì§€ë§Œ ê¾¸ì¤€íˆ ë‹¤ê°€ì˜´
            boss.userData.walkOffset = 0;
            boss.userData.hp = 50; // ë³´ìŠ¤ ì²´ë ¥ (50ë°œ ëª…ì¤‘ í•„ìš”)
            boss.userData.isBoss = true;
            boss.userData.attackRadius = 4.5; // ë©ì¹˜ê°€ ì»¤ì„œ ê³µê²© ë°˜ê²½ë„ ë„“ìŒ

            scene.add(boss);
            enemies.push(boss);
        }

        // --- ê²½í—˜ì¹˜ ë° ë ˆë²¨ ì‹œìŠ¤í…œ ---
        function gainExp(amount) {
            currentExp += amount;
            while (currentExp >= maxExp) {
                currentExp -= maxExp;
                levelUp();
            }
            updateHUD();
        }

        function levelUp() {
            level++;
            maxExp += 10; // ë ˆë²¨ì—… ë§ˆë‹¤ ìµœëŒ€ ê²½í—˜ì¹˜ 10 ì¦ê°€
            
            // 5ë ˆë²¨ íŠ¹ì „: íƒ„ì°½ ì¦ê°€
            if (level === 5) {
                maxAmmo = 50;
                currentAmmo = maxAmmo;
                updateAmmoHUD();
            }
            
            // ë ˆë²¨ì—… ë©”ì‹œì§€ í‘œì‹œ
            const msg = document.getElementById('boss-msg');
            msg.innerText = `LEVEL UP! (Lv.${level})`;
            msg.style.color = '#00FF00';
            msg.style.display = 'block';
            setTimeout(() => { 
                msg.style.display = 'none'; 
                msg.style.color = '#FFD700'; 
                msg.innerText = 'BOSS CLEARED!'; 
            }, 2000);
        }

        function killEnemy(enemy, index) {
            scene.remove(enemy);
            enemies.splice(index, 1);
            
            if (enemy.userData.isBoss) {
                score += 100;
                gainExp(100); // ë³´ìŠ¤ ê²½í—˜ì¹˜ 100
                document.getElementById('medals').innerText += 'ğŸ…';
                
                const msg = document.getElementById('boss-msg');
                msg.innerText = 'BOSS CLEARED!';
                msg.style.color = '#FFD700';
                msg.style.display = 'block';
                setTimeout(() => { msg.style.display = 'none'; }, 3000);
            } else {
                score += 10;
                gainExp(30); // ì¼ë°˜ ì¢€ë¹„ ê²½í—˜ì¹˜ 30
                
                spawnEnemy();
                if (Math.random() < 0.3) spawnEnemy();
            }
            updateHUD();
        }

        // --- ì‚¬ìš´ë“œ íš¨ê³¼ (Web Audio API) ---
        async function loadAudioFiles() {
            try {
                // ì²¨ë¶€í•´ì£¼ì‹  ì‹¤ì œ ì¥ì „ ì†Œë¦¬ ì˜¤ë””ì˜¤ íŒŒì¼ ë¡œë“œ (ì§ì ‘ íŒŒì¼ëª…ìœ¼ë¡œ í˜¸ì¶œ)
                const response = await fetch('ì´ ì¥ì „ ì†Œë¦¬.mp3');
                if (!response.ok) throw new Error('Network response was not ok');
                const arrayBuffer = await response.arrayBuffer();
                reloadSoundBuffer = await audioCtx.decodeAudioData(arrayBuffer);
            } catch (error) {
                console.warn("ì¥ì „ ì†Œë¦¬ ë¡œë“œ ì‹¤íŒ¨ (í•©ì„±ìŒìœ¼ë¡œ ëŒ€ì²´ë¨):", error);
            }
        }

        function playShootSound() {
            if (!audioCtx) return;
            
            // ì´ì†Œë¦¬(ë°±ìƒ‰ ì†ŒìŒ + ë¡œìš°íŒ¨ìŠ¤ í•„í„°) ì‹¤ì‹œê°„ ìƒì„±
            const bufferSize = audioCtx.sampleRate * 0.2; // 0.2ì´ˆ ê¸¸ì´
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1; // ë°±ìƒ‰ ì†ŒìŒ(White Noise)
            }
            
            const noiseSource = audioCtx.createBufferSource();
            noiseSource.buffer = buffer;
            
            // í•„í„° ì ìš© (ë¨¹ë¨¹í•˜ê³  ë¬µì§í•œ ì´ì†Œë¦¬ ëŠë‚Œ ë§Œë“¤ê¸°)
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(2000, audioCtx.currentTime);
            filter.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.2);
            
            // ë³¼ë¥¨ ì¡°ì ˆ (ì ì  ê°ì†Œ)
            const gainNode = audioCtx.createGain();
            gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
            
            // ë…¸ë“œ ì—°ê²°: ì†ŒìŠ¤ -> í•„í„° -> ë³¼ë¥¨ -> ì¶œë ¥
            noiseSource.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            noiseSource.start();
        }

        function playReloadSound() {
            if (!audioCtx) return;

            if (reloadSoundBuffer) {
                // ë¡œë“œëœ ì‹¤ì œ ì˜¤ë””ì˜¤ íŒŒì¼ì„ ì¬ìƒ
                const source = audioCtx.createBufferSource();
                source.buffer = reloadSoundBuffer;
                source.connect(audioCtx.destination);
                source.start(0);
            } else {
                // íŒŒì¼ ë¡œë“œ ì‹¤íŒ¨ ì‹œ ë°±ì—…ìš© í•©ì„±ìŒ(ì² ì»¥) ì¬ìƒ
                const time = audioCtx.currentTime;
                createMetallicClick(time + 0.1, 800, 0.08, 0.6);
                createMetallicClick(time + 0.5, 400, 0.15, 1.0);
                createMetallicClick(time + 0.9, 1800, 0.1, 0.8);
                createMetallicClick(time + 1.05, 2500, 0.15, 1.0);
                createMetallicClick(time + 1.05, 300, 0.15, 0.8);
            }
        }

        function createMetallicClick(startTime, frequency, duration, volume) {
            // ë°±ìƒ‰ ì†ŒìŒ(White Noise) ê¸°ë°˜ìœ¼ë¡œ ê¸ˆì† ë§ˆì°°ìŒ ìƒì„±
            const bufferSize = audioCtx.sampleRate * duration;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }

            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;

            // ëŒ€ì—­ í†µê³¼ í•„í„° (Bandpass)
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.setValueAtTime(frequency, startTime);
            filter.Q.value = 8; 

            // ë³¼ë¥¨ ì—”ë²¨ë¡œí”„
            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(0.001, startTime);
            gain.gain.exponentialRampToValueAtTime(volume, startTime + 0.01); 
            gain.gain.exponentialRampToValueAtTime(0.001, startTime + duration); 
            
            noise.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);
            
            noise.start(startTime);
        }

        // --- ë¬´ê¸° ë°œì‚¬ ë¡œì§ (ë‹¨ë°œ/ì—°ì‚¬ ê³µí†µ) ---
        function fireGun() {
            if (currentAmmo <= 0) {
                document.getElementById('ammo-text').innerText = "RELOAD (R)";
                document.getElementById('ammo-text').style.color = "red";
                return;
            }

            lastFireTime = performance.now();
            currentAmmo--;
            updateAmmoHUD();

            // ì´ì†Œë¦¬ ì¬ìƒ
            playShootSound();

            // 1. ì´ê¸° ë°˜ë™ ì• ë‹ˆë©”ì´ì…˜
            gun.position.z = -0.4; 
            gun.rotation.x = 0.1;  
            setTimeout(() => {
                if (!isReloading) {
                    gun.position.z = -0.5; 
                    gun.rotation.x = 0;
                }
            }, 80); // ì—°ì‚¬ë¥¼ ìœ„í•´ ë°˜ë™ ë³µêµ¬ ì‹œê°„ ë‹¨ì¶•

            // 2. ë ˆì´ìºìŠ¤íŠ¸ (í™”ë©´ ì¤‘ì•™ì—ì„œ ê´‘ì„  ë°œì‚¬)
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            
            const intersects = raycaster.intersectObjects(enemies, true);

            if (intersects.length > 0) {
                const hitEnemy = intersects[0].object.userData.parentZombie;
                const hitPoint = intersects[0].point;
                
                if (hitEnemy) {
                    createHitEffect(hitPoint);
                    hitEnemy.userData.hp--;

                    if (hitEnemy.userData.hp <= 0) {
                        killEnemy(hitEnemy, enemies.indexOf(hitEnemy));
                    } else if (hitEnemy.userData.isBoss) {
                        hitEnemy.position.x -= raycaster.ray.direction.x * 0.2;
                        hitEnemy.position.z -= raycaster.ray.direction.z * 0.2;
                    }
                }
            }
        }

        // --- ìœ íƒ„ ë°œì‚¬ ì‹œìŠ¤í…œ (15ë ˆë²¨) ---
        function fireGrenade() {
            const time = performance.now();
            if (time - lastGrenadeTime < 1500) return; // 1.5ì´ˆ ì¿¨íƒ€ì„
            lastGrenadeTime = time;

            const geometry = new THREE.SphereGeometry(0.15, 8, 8);
            const material = new THREE.MeshPhongMaterial({color: 0x333333});
            const grenade = new THREE.Mesh(geometry, material);
            
            // ì¹´ë©”ë¼ ìœ„ì¹˜ì—ì„œ ë°œì‚¬
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const startPos = raycaster.ray.origin.clone();
            const dir = raycaster.ray.direction.clone();
            
            grenade.position.copy(startPos);
            // ë°œì‚¬ ì†ë„: ì•ìœ¼ë¡œ 20, ìœ„ë¡œ 3
            grenade.userData.velocity = dir.multiplyScalar(20).add(new THREE.Vector3(0, 3, 0));
            grenade.userData.lifespan = 3.0; // 3ì´ˆ ë’¤ ìë™ í­ë°œ

            scene.add(grenade);
            grenades.push(grenade);
        }

        function explodeGrenade(position) {
            // í­ë°œ ì´í™íŠ¸
            const particleCount = 40;
            const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            const mat = new THREE.MeshBasicMaterial({ color: 0xFF5722 }); // ì£¼í™©ìƒ‰ í­ë°œ

            for (let i = 0; i < particleCount; i++) {
                const p = new THREE.Mesh(geo, mat);
                p.position.copy(position);
                p.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 30,
                        Math.random() * 20,
                        (Math.random() - 0.5) * 30
                    ),
                    lifespan: 0.5 + Math.random() * 0.5
                };
                scene.add(p);
                particles.push(p); 
            }

            // ìŠ¤í”Œë˜ì‹œ ë°ë¯¸ì§€
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                if (enemy.position.distanceTo(position) < 8.0) { // í­ë°œ ë°˜ê²½ 8
                    enemy.userData.hp -= 20; // 20 ë°ë¯¸ì§€ (ì¼ë°˜ì¢€ë¹„ ì¦‰ì‚¬, ë³´ìŠ¤ ì¹˜ëª…ìƒ)
                    if (enemy.userData.hp <= 0) {
                        killEnemy(enemy, i);
                    }
                }
            }
        }

        function reloadGun() {
            isReloading = true;
            document.getElementById('ammo-text').innerText = "RELOADING...";
            document.getElementById('ammo-text').style.color = "yellow";
            
            // ì¥ì „ ì‚¬ìš´ë“œ ì¬ìƒ
            playReloadSound();

            // ì¥ì „ ì• ë‹ˆë©”ì´ì…˜ (ì´ì„ ì•„ë˜ë¡œ ë‚´ë¦¼)
            gun.rotation.x = -0.5;
            gun.position.y = -0.5;

            setTimeout(() => {
                currentAmmo = maxAmmo;
                isReloading = false;
                
                // ì´ ìœ„ì¹˜ ë³µêµ¬
                gun.rotation.x = 0;
                gun.position.y = -0.2;
                
                updateAmmoHUD();
            }, 1500); // 1.5ì´ˆ ì†Œìš”
        }

        function updateAmmoHUD() {
            document.getElementById('ammo-text').innerText = `${currentAmmo} / ${maxAmmo}`;
            document.getElementById('ammo-text').style.color = "white";
        }

        function updateHUD() {
            document.getElementById('score-text').innerText = `SCORE : ${score}`;
            document.getElementById('level-text').innerText = `LEVEL : ${level}`;
            document.getElementById('health-text').innerText = Math.max(0, health);
            document.getElementById('health-bar').style.width = `${Math.max(0, health)}%`;
            
            // ì²´ë ¥ ê²½ê³  ìƒ‰ìƒ
            if (health <= 30) {
                document.getElementById('health-bar').style.backgroundColor = '#880000';
            } else {
                document.getElementById('health-bar').style.backgroundColor = '#ff3333';
            }

            // ê²½í—˜ì¹˜ ë°” ì—…ë°ì´íŠ¸
            document.getElementById('exp-text').innerText = `${currentExp} / ${maxExp}`;
            const expPercent = Math.min(100, (currentExp / maxExp) * 100);
            document.getElementById('exp-bar').style.width = `${expPercent}%`;
        }

        function takeDamage(amount) {
            if (isGameOver) return;
            
            health -= amount;
            updateHUD();

            // í™”ë©´ ë¶‰ê²Œ ê¹œë¹¡ì„ íš¨ê³¼
            const overlay = document.getElementById('damage-overlay');
            overlay.style.opacity = 1;
            setTimeout(() => {
                overlay.style.opacity = 0;
            }, 150);

            if (health <= 0) {
                gameOver();
            }
        }

        function gameOver() {
            isGameOver = true;
            controls.unlock();
            
            document.getElementById('title-text').innerHTML = `<span style="color:red;">GAME OVER!</span>`;
            document.getElementById('desc-text').innerHTML = `ìµœì¢… ì ìˆ˜: ${score}<br><br><span style="font-size:22px; color:#ddd;">ë‹¤ì‹œ í”Œë ˆì´í•˜ë ¤ë©´ í´ë¦­í•˜ì„¸ìš”</span>`;
        }

        // íŒŒí‹°í´ ìƒì„± í•¨ìˆ˜
        function createHitEffect(position) {
            const particleCount = 15; // íŒŒí‹°í´ ê°œìˆ˜
            const geometry = new THREE.BoxGeometry(0.15, 0.15, 0.15);
            
            // ì¢€ë¹„ ì²´ì•¡ ëŠë‚Œì˜ ì´ˆë¡ìƒ‰ê³¼ ë‡Œ ëŠë‚Œì˜ í•‘í¬ìƒ‰ ì„ê¸°
            const materials = [
                new THREE.MeshBasicMaterial({ color: 0x8BC34A }), 
                new THREE.MeshBasicMaterial({ color: 0xF48FB1 })
            ];

            for (let i = 0; i < particleCount; i++) {
                const material = materials[Math.floor(Math.random() * materials.length)];
                const particle = new THREE.Mesh(geometry, material);
                
                particle.position.copy(position); // ë§ì€ ìœ„ì¹˜ì—ì„œ ì‹œì‘

                // ë¬´ì‘ìœ„ ì†ë„(ë°©í–¥) ì„¤ì •
                particle.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 15, // Xì¶• í¼ì§
                        Math.random() * 10 + 5,      // Yì¶• ì†Ÿêµ¬ì¹¨
                        (Math.random() - 0.5) * 15  // Zì¶• í¼ì§
                    ),
                    lifespan: 0.5 + Math.random() * 0.5 // 0.5ì´ˆ ~ 1.0ì´ˆ ìƒì¡´
                };

                scene.add(particle);
                particles.push(particle);
            }
        }

        function resetGame() {
            // ë³€ìˆ˜ ì´ˆê¸°í™”
            score = 0;
            health = 100;
            isGameOver = false;
            
            level = 1;
            currentExp = 0;
            maxExp = 100;
            maxAmmo = 30;
            currentAmmo = maxAmmo;
            
            isReloading = false;
            isFiring = false;
            activeTime = 0;
            nextBossTime = 30; // ë‹¤ì‹œ 30ì´ˆ ë’¤ ë³´ìŠ¤ ë“±ì¥
            
            // UI ì´ˆê¸°í™”
            document.getElementById('medals').innerText = ''; 
            document.getElementById('boss-msg').style.display = 'none';
            
            updateHUD();
            updateAmmoHUD();

            // ì´ ìœ„ì¹˜ ì´ˆê¸°í™”
            if (gun) {
                gun.rotation.x = 0;
                gun.position.y = -0.2;
                gun.position.z = -0.5;
            }

            // í”Œë ˆì´ì–´ ìœ„ì¹˜ ì´ˆê¸°í™”
            camera.position.set(0, 2, 0);
            
            // ê¸°ì¡´ ì  ëª¨ë‘ ì œê±°
            enemies.forEach(enemy => scene.remove(enemy));
            enemies = [];

            // ìƒˆ ì  ìŠ¤í°
            for (let i = 0; i < 15; i++) {
                spawnEnemy();
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ë©”ì¸ ê²Œì„ ë£¨í”„
        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();

            if (controls.isLocked === true && !isGameOver) {
                const delta = (time - prevTime) / 1000;

                // ê²Œì„ í”Œë ˆì´ ì‹œê°„ ëˆ„ì  ë° ë³´ìŠ¤ ìŠ¤í° ì²˜ë¦¬
                activeTime += delta;
                if (activeTime >= nextBossTime) {
                    spawnBoss();
                    nextBossTime += 30; // 30ì´ˆë§ˆë‹¤ ìƒˆë¡œìš´ ë³´ìŠ¤ ê³„ì† ë“±ì¥
                }

                // 5ë ˆë²¨ íŠ¹ì „: ì—°ì‚¬ (ì¢Œí´ë¦­ ìœ ì§€ ì¤‘ì¼ ë•Œ) - ê¸°ì¡´ 10ë ˆë²¨ì—ì„œ 5ë ˆë²¨ë¡œ ì¡°ì •
                if (level >= 5 && isFiring && !isReloading) {
                    if (time - lastFireTime > 150) { // ì—°ì‚¬ ì†ë„ (150ms)
                        fireGun();
                    }
                }

                // --- í”Œë ˆì´ì–´ ë¬¼ë¦¬/ì´ë™ ë¡œì§ ---
                // ì†ë„ ê°ì† (ë§ˆì°°ë ¥)
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 9.8 * 35.0 * delta; // ì¤‘ë ¥ì„ ì•½í™”ì‹œì¼œ ì‚¬ë¿í•˜ê²Œ ë–¨ì–´ì§€ë„ë¡ (ê¸°ì¡´ 100.0 -> 35.0)

                // ì´ë™ ë°©í–¥ ë²¡í„° ê³„ì‚°
                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveLeft) - Number(moveRight); // Aì™€ D í‚¤ ë°©í–¥ ë°˜ì „ ìˆ˜ì •
                direction.normalize(); // ëŒ€ê°ì„  ì´ë™ ì‹œ ì†ë„ ì¦ê°€ ë°©ì§€

                // ê°€ì†
                if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

                // ì¶©ëŒ ê°ì§€ë¥¼ ìœ„í•´ ì˜ˆìƒ ë‹¤ìŒ ìœ„ì¹˜ ê³„ì‚° (ê°„ì´ ë°©ì‹)
                const controlObj = controls.getObject();
                
                // 1. ì´ë™ ì „ì˜ ì•ˆì „í•œ ìœ„ì¹˜ ì €ì¥ (ê´€í†µ ë°©ì§€ìš©)
                const oldX = controlObj.position.x;
                const oldZ = controlObj.position.z;
                
                // 2. X, Z(ìˆ˜í‰) ì´ë™ ë¨¼ì € ì ìš©
                controlObj.translateX(velocity.x * delta);
                controlObj.translateZ(velocity.z * delta);
                
                // ë§µ ë°–ìœ¼ë¡œ ë‚˜ê°€ì§€ ëª»í•˜ê²Œ ê²½ê³„ì„  ì„¤ì •
                if (controlObj.position.x > 45) controlObj.position.x = 45;
                if (controlObj.position.x < -45) controlObj.position.x = -45;
                if (controlObj.position.z > 45) controlObj.position.z = 45;
                if (controlObj.position.z < -45) controlObj.position.z = -45;

                // 3. ë°”ë‹¥ ë° ë²½ë©´ ì¶©ëŒ íŒì • (ë‚˜ë¬´ êµ¬ì¡°ë¬¼ ì˜¬ë¼ê°€ê¸°)
                let floorY = 0; // ê¸°ë³¸ ì”ë”” ë°”ë‹¥ì˜ ë†’ì´
                const playerRadius = 0.6; // í”Œë ˆì´ì–´ ëª¸í†µ ë‘ê»˜ (ë²½ë©´ ê´€í†µì„ ë§‰ê¸° ìœ„í•´ 0.5->0.6ìœ¼ë¡œ ì•½ê°„ ëŠ˜ë¦¼)

                for (let i = 0; i < objects.length; i++) {
                    const box = objects[i];
                    const bw = box.geometry.parameters.width / 2;
                    const bd = box.geometry.parameters.depth / 2;
                    const topY = box.position.y + box.geometry.parameters.height / 2;

                    // í”Œë ˆì´ì–´ê°€ ë°•ìŠ¤ì˜ (X, Z) ìˆ˜í‰ ì˜ì—­ì„ ì¹¨ë²”í–ˆëŠ”ì§€ í™•ì¸
                    if (controlObj.position.x > box.position.x - bw - playerRadius &&
                        controlObj.position.x < box.position.x + bw + playerRadius &&
                        controlObj.position.z > box.position.z - bd - playerRadius &&
                        controlObj.position.z < box.position.z + bd + playerRadius) {
                        
                        // í”Œë ˆì´ì–´ì˜ ë°œ(ì¹´ë©”ë¼Y - 2)ì´ ë°•ìŠ¤ ìƒë‹¨ê³¼ ë¹„ìŠ·í•˜ê±°ë‚˜ ë” ë†’ë‹¤ë©´ (ìœ„ë¡œ ì˜¬ë¼íƒ)
                        if (controlObj.position.y - 2 >= topY - 1.0) {
                            floorY = Math.max(floorY, topY); // ë°Ÿê³  ìˆëŠ” ë†’ì´ë¥¼ ë°•ìŠ¤ ìœ„ë¡œ ë³€ê²½
                        } else {
                            // ë°œì´ ë°•ìŠ¤ë³´ë‹¤ ì•„ë˜ì— ìˆë‹¤ë©´ ì˜†ë©´ì— ë¶€ë”ªíŒ ê²ƒ -> ì´ì „ì˜ ì•ˆì „í•œ ìœ„ì¹˜ë¡œ ì™„ë²½í•˜ê²Œ ë˜ëŒë¦¼ (ë²½ ê´€í†µ ì°¨ë‹¨)
                            controlObj.position.x = oldX;
                            controlObj.position.z = oldZ;
                            velocity.x = 0;
                            velocity.z = 0;
                            break;
                        }
                    }
                }

                // 4. Yì¶•(ìˆ˜ì§) ì´ë™ ì ìš©
                controlObj.position.y += (velocity.y * delta); 

                // 5. ì¶”ë½ ì‹œ ë°”ë‹¥(ì”ë”” ë˜ëŠ” ë°•ìŠ¤ ìœ„)ì— ë‹¿ì•˜ëŠ”ì§€ í™•ì¸
                const targetCamY = floorY + 2; // ìµœì¢… ë°œíŒ ë†’ì´ + í”Œë ˆì´ì–´ í‚¤(2)
                if (controlObj.position.y <= targetCamY) {
                    velocity.y = 0;
                    controlObj.position.y = targetCamY;
                    canJump = true; // ë•…ì— ë‹¿ìœ¼ë©´ ì í”„ ì´ˆê¸°í™”
                }


                // --- ì  AI ë¡œì§ ---
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];

                    // í”Œë ˆì´ì–´ë¥¼ í–¥í•´ íšŒì „ (ì¢€ë¹„ê°€ ìœ„ì•„ë˜ë¡œ ëˆ•ì§€ ì•Šë„ë¡ Yì¶•ë§Œ íƒ€ê²ŸíŒ…)
                    const targetPos = controlObj.position.clone();
                    targetPos.y = enemy.position.y;
                    enemy.lookAt(targetPos);
                    
                    // ê±·ê¸° ì• ë‹ˆë©”ì´ì…˜ ê³„ì‚°
                    const walkSpeed = enemy.userData.speed * 4;
                    const walkTime = time * 0.001 * walkSpeed + enemy.userData.walkOffset;

                    // ì–‘íŒ”ì„ ì•ìœ¼ë¡œ ë»—ê³  ìœ„ì•„ë˜ë¡œ ìœ¼ìŠ¤ìŠ¤í•˜ê²Œ í—ˆìš°ì ê±°ë¦¼
                    enemy.userData.leftArm.rotation.x = -Math.PI / 2 + Math.sin(walkTime) * 0.15;
                    enemy.userData.rightArm.rotation.x = -Math.PI / 2 + Math.sin(walkTime + Math.PI) * 0.15;

                    // ë‹¤ë¦¬ ì•ë’¤ êµì°¨ë¡œ ê±·ê¸°
                    enemy.userData.leftLeg.rotation.x = Math.sin(walkTime) * 0.6;
                    enemy.userData.rightLeg.rotation.x = Math.sin(walkTime + Math.PI) * 0.6;

                    // ë¨¸ë¦¬ ì‚´ì§ ê¹Œë”±ê±°ë¦¬ê¸°
                    enemy.userData.head.rotation.y = Math.sin(walkTime * 0.5) * 0.2;
                    enemy.userData.head.rotation.z = Math.sin(walkTime) * 0.05;

                    // ì¢€ë¹„ë„ êµ¬ì¡°ë¬¼ ìœ„ì— ìì—°ìŠ¤ëŸ½ê²Œ ì˜¬ë¼ê°€ë„ë¡ ì§€í˜• ë†’ì´ íŒŒì•…
                    let zombieFloorY = 0;
                    for (let j = 0; j < objects.length; j++) {
                        const box = objects[j];
                        const bw = box.geometry.parameters.width / 2;
                        const bd = box.geometry.parameters.depth / 2;
                        if (enemy.position.x > box.position.x - bw && enemy.position.x < box.position.x + bw &&
                            enemy.position.z > box.position.z - bd && enemy.position.z < box.position.z + bd) {
                            zombieFloorY = Math.max(zombieFloorY, box.position.y + box.geometry.parameters.height / 2);
                        }
                    }

                    // ëª¸ ê¿€ë ì„ íš¨ê³¼ + ì§€í˜•(ìƒì) ë†’ì´ ì ìš©
                    enemy.position.y = zombieFloorY + Math.abs(Math.sin(walkTime)) * 0.1;

                    // í”Œë ˆì´ì–´ë¥¼ í–¥í•´ ì´ë™
                    const speed = enemy.userData.speed * delta;
                    enemy.translateZ(speed);

                    // í”Œë ˆì´ì–´ì™€ì˜ ì¶©ëŒ(í”¼ê²©) ê°ì§€
                    const distance = enemy.position.distanceTo(controlObj.position);
                    if (distance < enemy.userData.attackRadius) { // ë©ì¹˜ì— ë¹„ë¡€í•œ ê³µê²© ë°˜ê²½
                        takeDamage(enemy.userData.isBoss ? 20 : 10); // ë³´ìŠ¤ëŠ” ë°ë¯¸ì§€ë„ ë‘ ë°°(20)
                        
                        // ì ì´ ë¶€ë”ªíˆë©´ íŠ•ê²¨ì ¸ ë‚˜ê°€ëŠ” íš¨ê³¼ (ìœ„ì¹˜ ì¬ì¡°ì •)
                        enemy.position.x += (Math.random() - 0.5) * (enemy.userData.isBoss ? 5 : 20); // ë³´ìŠ¤ëŠ” ë¬´ê±°ì›Œì„œ ì¡°ê¸ˆë§Œ ë°€ë¦¼
                        enemy.position.z += (Math.random() - 0.5) * (enemy.userData.isBoss ? 5 : 20);
                        
                        // ë„ˆë¬´ ë©€ë¦¬ê°€ë©´ ë‹¤ì‹œ ì•ˆìª½ìœ¼ë¡œ ë³´ì •
                        if(Math.abs(enemy.position.x) > 40) enemy.position.x = 0;
                        if(Math.abs(enemy.position.z) > 40) enemy.position.z = 0;
                    }
                }

                // --- íŒŒí‹°í´(íƒ€ê²© ì´í™íŠ¸) ë¬¼ë¦¬ ë¡œì§ ---
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.userData.lifespan -= delta;

                    if (p.userData.lifespan <= 0) {
                        // ìˆ˜ëª…ì´ ë‹¤í•˜ë©´ ì œê±°
                        scene.remove(p);
                        particles.splice(i, 1);
                    } else {
                        // ì¤‘ë ¥ ì ìš©
                        p.userData.velocity.y -= 9.8 * 3.0 * delta; 
                        
                        // ì´ë™ ì ìš©
                        p.position.x += p.userData.velocity.x * delta;
                        p.position.y += p.userData.velocity.y * delta;
                        p.position.z += p.userData.velocity.z * delta;

                        // ì‹œê°„ì´ ì§€ë‚ ìˆ˜ë¡ í¬ê¸° ì¤„ì–´ë“¤ê¸°
                        p.scale.multiplyScalar(0.92);
                    }
                }

                // --- ìœ íƒ„ ë¬¼ë¦¬ ë¡œì§ ---
                for (let i = grenades.length - 1; i >= 0; i--) {
                    const g = grenades[i];
                    g.userData.lifespan -= delta;
                    
                    g.userData.velocity.y -= 9.8 * 2.0 * delta; // ìœ íƒ„ ì¤‘ë ¥
                    
                    g.position.x += g.userData.velocity.x * delta;
                    g.position.y += g.userData.velocity.y * delta;
                    g.position.z += g.userData.velocity.z * delta;
                    
                    let exploded = false;
                    
                    // 1. ë°”ë‹¥ ì¶©ëŒ
                    if (g.position.y <= 0.2) exploded = true;

                    // 2. êµ¬ì¡°ë¬¼ ì¶©ëŒ
                    if (!exploded) {
                        for (let j = 0; j < objects.length; j++) {
                            const box = objects[j];
                            const bw = box.geometry.parameters.width / 2;
                            const bd = box.geometry.parameters.depth / 2;
                            const bh = box.geometry.parameters.height / 2;
                            if (g.position.x > box.position.x - bw && g.position.x < box.position.x + bw &&
                                g.position.z > box.position.z - bd && g.position.z < box.position.z + bd &&
                                g.position.y > box.position.y - bh && g.position.y < box.position.y + bh) {
                                exploded = true;
                                break;
                            }
                        }
                    }

                    if (exploded || g.userData.lifespan <= 0) {
                        explodeGrenade(g.position);
                        scene.remove(g);
                        grenades.splice(i, 1);
                    }
                }

                // --- êµ¬ë¦„ ì´ë™ ë¡œì§ ---
                for (let i = 0; i < clouds.length; i++) {
                    clouds[i].position.x += clouds[i].userData.speed * delta;
                    
                    // êµ¬ë¦„ì´ í™”ë©´(ë§µ) ì˜¤ë¥¸ìª½ ëìœ¼ë¡œ ë©€ë¦¬ ë‚˜ê°€ë©´ ì™¼ìª½ ëìœ¼ë¡œ ë‹¤ì‹œ ë°°ì¹˜
                    if (clouds[i].position.x > 100) {
                        clouds[i].position.x = -100;
                        clouds[i].position.z = (Math.random() - 0.5) * 200;
                    }
                }
            }

            prevTime = time;
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>